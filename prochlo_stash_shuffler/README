##############################################
# Enclave implementation of the Stash Shuffler
##############################################

Disclaimer
----------

This is not an official Google product. It is a demonstration of the Stash
Shuffle algorithm, described in

Prochlo: Strong Privacy for Analytics in the Crowd, Andrea Bittau, Ãšlfar
Erlingsson, Petros Maniatis, Ilya Mironov, Ananth Raghunathan, David Lie, Mitch
Rudominer, Usharee Kode, Julien Tinnes, and Bernhard Seefeld. Symposium on
Operating Systems Principles, 2017.


Overview
~~~~~~~~

untrusted/*: This directory contains all the code that will run in untrusted
user space.  It will also be where the Enclave_u.* edger8er generated files will
go.

Makefile: The base make file for building everything. It includes a Makefile.inc
from Intel's SGX SDK.

Makefile.inc: These are SGX-specific rules for building enclaves and getting the
right includes to build code that calls enclaves.  Based off the example
Makefiles from the SGX SDK.

Enclave.edl: This is the edl file that defines the interface between the enclave
and its untrusted application counterpart.

Enclave.cc/.h: This is the entry-point into the enclave.  The main thing is it
builds the necessary objects to call the stash shuffler, takes the arguments for
ecall_* and uses them to call the actual stash_shuffler

Enclave.lds: Definition of ecalls and ocalls.

Enclave_private.pem: Key to sign enclave code.  Needed for hardware enclaves.

Enclave.config.xml: File where you can set the memory allocated to Enclave.  Set
to use the maximum amount of heap (around ~90MB).


Ecalls/Ocalls
~~~~~~~~~~~~~

These are defined in the Enclave.edl file.  The specific functions and their
purpose is:

ecall_set_key: This sets the Shuffler's keypair. In a production deployment,
this would be generated by the Shuffler and attested for publication.

ecall_shuffle: This is the main entry point that runs the shuffler.

ecall_distribute: This only invokes the distribution phase of the shuffle. It is
mostly for debugging purposes, since it uses an externally-provided symmetric
encryption key.

ecall_clean_up: This only invokes the clean up phase of the shuffle. It is
mostly for debugging purposes, since it uses an externally-provided symmetric
encryption key.

ocall_print_string: ocall to allow the enclave to print stuff to the console.
The ocall handler adds a "*" before each line so you can tell what is printed by
the enclave and what is printed by the main application.

ocall do_getttimeofday_start/end: These are functions used to measure the amount
of time between 2 points in the program.  End takes an arbitrary integer that is
printed along with the output so it makes it easier to pass an additional
integer of information out.


Building
~~~~~~~~

Building requires the following invocation:

make SGX_MODE=HW SGX_PRERELEASE=1 

SGX_MODE=HW SGX_PRERELEASE=1: this gets you a hardware enclave.  Otherwise
you'll end up running in SGX simulation


Creating Input Files
--------------------

To input file to the Shuffler must contain properly encrypted data, packaged
into ShufflerItems. The generator binary generates such data for this demo. In a
production setting, individual clients would send such items to a Shuffler
service, which in turn would invoke the StashShuffler for the actual shuffling
and decryption.

To generate a test file at /tmp/testfile.dat with 5000 ShufflerItems, using the
key pairs for the Shuffler and Analyzer at etc/shuffler.pub.pem and
etc/analyzer.pub.pem, respectively, invoke:

# generator/generator -o /tmp/testfile.dat -S etc/shuffler.pub.pem \
#   -A etc/analyzer.pub.pem -n 5000

Note that the keys are generated when you

# make

Since the generated test file is dependent on the Shuffler and Analyzer keys you
used, you should save those keys along with the test file for further
processing.


Shuffling
---------

To shuffle a file of ShufflerItems, invoke:

# stash_shuffle <number_of_items> <number_of_buckets> <number_of_chunks> \
#    <stash_size> <number_of_chunks_for_stash_draining> <window_size> \
#    <input_file> <intermediate_file> <output_file> <shuffler_private_key>

The <input_file> must have been generated as described above, and the
<shuffler_private_key> must be the private key corresponding to the public key
used to generate the file.

The two other files <intermediate_file> and <output_file> are used to store
temporary data, and the shuffled AnalyzerItems, respectively.

For debugging, you can invoke stash_distribute and stash_clean_up, instead of
stash_shuffle (with the exact same options), to split the two phases. Note that
when invoked separately, the two phases use a known symmetric key for the
encryption of intermediate shuffler items.